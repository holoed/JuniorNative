data Layer k = InputLayer 
             | DenseLayer (List (List Double)) (List Double) k 
             deriving Functor
             
val brain :: Fix Layer
let brain = In (DenseLayer [[0],[0]] [0,0] (In (DenseLayer [[0],[0]] [0,0] (In InputLayer))))

val sigma :: List Double -> List Double
let sigma = fmap (\x -> 1 / (1 + exp (0 - x)))

-- vector addition
val add :: List Double -> List Double -> List Double
let add xs ys = zipWith (+) xs ys

-- matrix-vector multiplication
val mul :: List (List Double) -> List Double -> List Double
let mul xss ys = fmap (sum . zipWith (*) ys) xss

val algfwd :: Layer (List Double -> List (List Double)) -> (List Double -> List (List Double))
let algfwd v = match v with
            | InputLayer -> \a0 -> [a0]
            | DenseLayer wl bl forwardPass -> 
              (\as -> let (a, as') = (head as, tail as) in
                      let al = sigma (add (mul wl a) bl) in
                      (al:a:as')) . forwardPass

val calc :: Fix Layer -> List Double -> List (List Double)
let calc = cataRec algfwd
 
let main = calc brain [0.0, 1.0]

      