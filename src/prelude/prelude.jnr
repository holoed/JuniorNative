-- Junior Prelude 

val const :: a -> b -> a
let const x y = x

val id :: a -> a
let id x = x

val fst :: (a, b) -> a
let fst (x, y) = x

val snd :: (a, b) -> b
let snd (x, y) = y

val flip :: (a -> b -> c) -> b -> a -> c
let flip f x y = f y x

val (.) :: (b -> c) -> (a -> b) -> a -> c
let (.) f g = \x -> f (g x)

val min :: Ord a => a -> a -> a
let min x y = if x > y then y else x

val max :: Ord a => a -> a -> a
let max x y = if x > y then x else y

val maybeToList :: Maybe a -> List a
let maybeToList = foldr (:) [] 

val listToMaybe :: List a -> Maybe a
let listToMaybe = foldr (const . Just) Nothing

val foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
let foldr1 f xs = 
   let mf x m = Just (foldr f x m) in
   fromMaybeLazy (error "foldr1: empty structure") (foldr mf Nothing xs) 

val sum :: (Foldable t, Num a) => t a -> a
let sum = foldr (+) 0

val product :: (Foldable t, Num a) => t a -> a
let product = foldr (*) 1

val flatten :: Monad m => m (m a) -> m a
let flatten xs = bind xs id  

val sequenceA :: (Applicative f, Traversable t) => t (f a) -> f (t a)
let sequenceA = traverse id

val liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
let liftA3 f m n o = (pure f) <*> m <*> n <*> o


